/**
 * phant-stream-csv
 * https://github.com/sparkfun/phant-stream-csv
 *
 * Copyright (c) 2014 SparkFun Electronics
 * Licensed under the GPL v3 license.
 */

'use strict';

/**** Module dependencies ****/
var stream = require('stream'),
    rotate = require('log-rotate'),
    helpers = require('./helpers'),
    path = require('path'),
    util = require('util'),
    fs = require('fs');

/**** Make Writable a writable stream ****/
util.inherits(Writable, stream.Writable);

/**** Writable prototype ****/
var app = Writable.prototype;

/**** Expose Writable ****/
exports = module.exports = Writable;

/**** Initialize a new Writable ****/
function Writable(id, options) {

  if (! (this instanceof Writable)) {
    return new Writable(id, options);
  }

  options = options || {};

  stream.Writable.call(this, options);

  // id generated by metadata module
  this.id = id;

  // apply the options
  util._extend(this, options);

  this.helpers = helpers({root: this.root});

  // generate the file path based on ID
  this.getFilePath();

  // once we have a path, open the file
  // for reading and writing
  this.once('path', function() {
    this.open();
  });

  this.once('finish', this.close);

}

app.file = null;
app.root = path.join('tmp');
app.cap = 50 * 1024 * 1024; // 50mb limit for streams
app.chunk = 500 * 1024; // 500k chunks
app.flags = 'a+'; // append + read
app.mode = 438; // 0666

app.getFilePath = function() {

  var self = this;

  this.helpers.filePath(this.id, 0, function(err, file) {

    self.file = file;

    self.emit('path', self.file);

  });

};

app.writeHeaders = function(headers) {

  var self = this;

  this.helpers.headerPath(this.id, function(err, file) {

    fs.exists(file, function(exists) {

      if(exists) {
        return;
      }

      fs.writeFile(file, headers, function(err) {
        if(err) {
          self.emit('error', err);
        }
      });

    });

  });

};

app.open = function() {

  var self = this;

  if(! this.file) {
    return this.once('path', function() {
      self.open();
    });
  }

  fs.open(this.file, this.flags, this.mode, function(err, fd) {

    if(err) {
      self.close();
      self.emit('error', err);
      return;
    }

    self.fd = fd;

    fs.fstat(fd, function(err, st) {

      if(err) {
        return this.emit('error', err);
      }

      self.size = st.size;
      self.emit('open', fd);

    });

  });

};

app._write = function(data, encoding, cb) {

  var self = this;

  if(typeof this.fd !== 'number') {

    return this.once('open', function() {
      self._write(data, encoding, cb);
    });

  }

  if (this.size + data.length > this.chunk) {
    this.rotate();
    this.once('open', function() {
      self.writeData(data, cb);
    });
  } else {
    this.writeData(data, cb);
  }

};

app.writeData = function(data, cb) {

  var self = this;

  fs.write(this.fd, data, 0, data.length, this.pos, function(err, bytes) {

    if(err) {
      self.close();
      return cb(err);
    }

    self.size += bytes;
    cb();

  });

};

app.rotate = function() {

  var self = this,
      keep = Math.floor(this.cap / this.chunk);

  // close the file
  this.close();

  rotate(this.file, { count: keep }, function(err) {

    if(err) {
      return self.emit('error', err);
    }

    self.open();

  });

};

app.close = function() {

  var self = this;

  if(typeof this.fd !== 'number') {
    return;
  }

  fs.close(this.fd, function(err) {

    if(err) {
      self.emit('error', err);
    }

  });

};

